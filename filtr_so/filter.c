#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "filter.h"
#include "filter_grammar.h"
#include "filter_scanner.h"
#include "filter_proto.h"
#include "filter_semcheck.h"


// These functions are generated by lemon
void* DfilterAlloc(void* (*)(size_t));
void* Dfilter(void*, int, stnode_t*, dfwork_t*);
void* DfilterFree(void*, void(*)(void*));

filter_field_t *g_filter_fields;

stnode_t *df_lval;

void dfilter_fail(dfwork_t *dfw, const char *format, ...)
{
	va_list	args;

	/* If we've already reported one error, don't overwite it */
	if (dfw->error_message != NULL)
		return;

	// va_start(args, format);
	// vsprintf(dfw->error_message, format, args);
	// va_end(args);
}

static dfwork_t* dfwork_new(void)
{
	dfwork_t *dfw;

	dfw = malloc(sizeof(dfwork_t));
    memset(dfw, 0, sizeof(dfwork_t));

	return dfw;
}

static void dfwork_free(dfwork_t *dfw)
{
	if (dfw->st_root) {
		stnode_free(dfw->st_root);
	}

	/*
	 * We don't free the error message string; 
	 * our caller will return it to its caller.
	 */
	free(dfw);
}

void printnode(stnode_t *node)
{
    if (!node) {
        return ;
    }
    if(node->type == STTYPE_TEST) {
        test_t	*test = (test_t*)stnode_data(node);
        printf("op: %s\n", operandname(test->op));
        printnode(test->val1);
        printnode(test->val2);
    } else if(node->type == STTYPE_INTEGER) {
        printf("%d\n", node->value);
    } else {
        printf("%s\n", (char*)node->data);
    }
}

void print(dfwork_t	*dfw)
{
    stnode_t *node = dfw->st_root;
    printnode(node);
}


/*
 * memory free
 */
void filter_fini(dfwork_t *dfw)
{
    if (dfw) {
        if (dfw->error_message) {
            printf("[Error]: %s\n", dfw->error_message);
            free(dfw->error_message);
            dfw->error_message = NULL;
        }
        dfwork_free(dfw);
        dfw = NULL;
    }
    proto_fini();
}


/*
 * Parse filter expression and generate syntax tree
 */
int filter_init(char *expression/*in*/, dfwork_t **dfw/*out*/) 
{
    yyscan_t scanner;
    YY_BUFFER_STATE in_buffer;
    df_scanner_state_t state;

    if (proto_init() != TRUE) {
        printf("[Error]: proto_init() error!\n");
        return -1;
    }
    if (proto_explore() != TRUE) {
        printf("[Error]: proto_explore() error!\n");
        return -1;
    }

    df_lex_init(&scanner);

    void* parser = DfilterAlloc(malloc);
    in_buffer = df__scan_string(expression, scanner);
    *dfw = dfwork_new();
    state.dfw = *dfw;
	state.quoted_string = NULL;

    df_set_extra(&state, scanner);

    int lexToken;
    while(1) {
        df_lval = stnode_new(STTYPE_UNINITIALIZED, NULL);
        lexToken = df_lex(scanner);

        if (0 == lexToken) 
            break;
        if (-1 == lexToken) {
            fprintf(stderr, "[Error]: The scanner encountered an error.\n");
            return -1;
        }

        // print syntax tree node
        if (df_lval->type == STTYPE_INTEGER)
            printf("Token: %d Text:(m:%x t:%d i:%d)\n", lexToken, df_lval->magic, df_lval->type, df_lval->value);
        else
            printf("Token: %d Text:(m:%x t:%d d:%s)\n", lexToken, df_lval->magic, df_lval->type, (char*)df_lval->data);

        Dfilter(parser, lexToken, df_lval, *dfw);
    } 

    if (df_lval) {
		stnode_free(df_lval);
		df_lval = NULL;
	}

    Dfilter(parser, 0, NULL, *dfw);
    DfilterFree(parser, free);
    
    if ((*dfw)->syntax_error) {
        printf("[Error]: syntax_error!\n");
		return -1;
    }
    if (state.quoted_string != NULL) {
        g_string_free(state.quoted_string, TRUE);
    }

    df__delete_buffer(in_buffer, scanner);
    df_lex_destroy(scanner);

    if ((*dfw)->st_root == NULL) {
        printf("[Error]: no valid filter expression!\n");
    } else {
        if(!dfw_semcheck(*dfw)) {
            printf("[Error]: %s parse failed, please make sure the input correct!\n", expression);
            return -1;
        }
    }

    return 0;
}


/*
 * Call back the specified field judgment function to 
 * determine whether the filter conditions are met. 
 */
int filter_start(dfwork_t *dfw, void *data, pfunc_t pfunc)
{
    if (!dfw) {
        return -1;
    }

    // print syntax tree
    print(dfw);
    // callback
    gboolean ret = pfunc(dfw, data);
    if (FALSE == ret) {
        return -1;
    }

    return 0;
}
